# **Udacity Self Driving Car Nanodegree Program Project : Advanced Lane Finding** Detecting the lane lines is one of the first step performed in the approach for a self driving car. In this Advance lane finding project we are trying to detect the lane markings on road.The goal of the project is to make a pipeline that finds the lane on the road on a video or image. Also it will provide the radius of curvature of the road and also the distance to the center of the road.[//]: # (Image References)### Steps performed in detecting lanes on a image1. Camera Calibration: The first step performed is calibrating the camera. The code of camera calibration is present in `.\camera_cal\camera_cal.py` . For calibrating camera I am using checkered board images and finding object points and image points. I am using 20 checkered board images for performing camera calibration. Using the detected object points I am detecting the camera matrix values and the distortion co-efficient. The detected camera matrix values and the distortion co-efficient are stored in a pickle file and is used and the camera calibration parameters throughout the project.I am also drawing the detected corners in the images used for calibration. As a reference attaching one image with corners drawn[image1]: ./camera_cal/corners_found8.jpg "Camera Calibration with corners drawn"![alt text][image1]2. Undistorting the image:The next step I performed is undistorting the test images. The code for this is present in `.\distortion_corr.py` . Here I am using the calculated the camera matrix values and the distortion co-efficient and which was calculated previously.[image2]: ./output_images/Undistorted_test1.jpg "Undistorted Image"![alt text][image2]3. Binary image generation:Next I am using the undistorted image and created a binary image out of it. For creating the binary image I am making use of the sobel method, magnitude gradient method, direction gradient method and also the color space gradient. In the end I am taking a combination of all the 4 and creating a binary image which can be used. The code is present in  `.\binary_img_gen.py` . [image3]: ./output_images/CombinedColorGrad_test1.jpg "Binary gradient Image"![alt text][image3]4. Perspective transform :In the next step I am performing the perspective transform on the Binary image. The code is present at `.\prespective_transf.py`. For this I am first detecting a region of interest.  Then based on this region of interest I am calculating the parameters for perspective transform and also calculating the values for perform inverse perspective transform. By using the perspective transform parameters I am creating a warped binary image[image4]: ./output_images/Warped_test1.jpg "Warped Image"![alt text][image4]5. Lane Detection , Polynomial fitting and drawing lanes:This is the step where most of the image processing is performed. The code is placed at the location `.\lane_det_poly_fit.py`.First part is to take the warped image and using a histogram method first detecting the left lane and right lane starting point. From this starting point I am defining a small window and detecting the lane points. Then once the window detection is complete we move forward and detect the lanes in next window and so on. The number of windows is defined. We are also drawing a rectangle in the region where lane is detected. [image5]: ./output_images/Lane_Detec_slide_test1.jpg "Sliding windows lane detection"![alt text][image5]Then based on the detected lane points on left and right I am fitting a second order polynomial. Based on the polynomial points I am  finally fitting the left and right lanes . Based on the left and right lane points I am drawing a lane of red and blue color. The middle region of these 2 lanes are detected and I am filling a green color. I am drawing these lanes on a empty image so I can remove any disturbances.[image6]: ./output_images/Lane_Detec_warp_test1.jpg "Lane drawing on warped image"![alt text][image6]6. Perform inverse transform and adding the image:In the next step I am taking the lanes and middle region drawn image and performing an inverse perspective transform based on the same values calculated image in step 4. the code for this is present in `.\inverse_perspective.py`[image7]: ./output_images/Lane_Detec_Unwarpped_test1.jpg " Unwarped image with lanes"![alt text][image7]---### Pipe line function for imagesCombining all the above steps I created a pipeline for performing all the  steps and give a final output image. The code for this is  `.\pipeline.py`.All the steps are similar in this except after the last step of inverse perspective transform I am adding that image onto to the input image and obtaining the final image as lanes overlaid on the input image. Additional to this I am also calculating the radius of curvature and distance to the center of road using the left and right lane points and printing it onto to the final image[image8]: ./output_images/Lane_det_final_test1.jpg " Final output image"![alt text][image8]### Pipe line function for VideosThe same pipe line was copied and added the video processing part and created the final code for the project. The code is placed at  `.\pipeline_video_gen.py`.This pipeline was used to feed in the project requirement video(project_video.MP4) and it was able to successfully detect the lanes and print out the radius of curvature and distance to center in each frame. The output is placed at  `.\output_videos\output_video_lane_find.MP4`.### 2. Potential shortcomings with your current pipeline1) I tried the same pipeline on the challenge video and  the hard challenge video. In both the scenarios the lanes are getting misread and being drawn in incorrect positions2) Also observed that when there are more number of curves the lane detection is failing### 3. Possible improvements to your pipeline1. Try implementing a low pass filter to reduce noise2. Also increase the efficiency in the way the lane detection algorithm is happening so that even the challenge videos can be detected accurately